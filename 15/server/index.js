const path = require('path')
const express = require('express')
const graphqlHTTP = require('express-graphql')
const schema = require('./schema.js')

const {
    PORT = 3000,
    PWD = __dirname
} = process.env

const app = express()

//**(4) create a graphql API server */
app.use('/q', graphqlHTTP(req => ({
    schema,
    context: req.session
})))

//**(2) when the web script looks for /dist, it will point to primary working directory(where package.json is) and build/public */
//**(9) client folder stuffs will webpack compiled into build/public per webpack.config.js
//**(10) server folder stuffs will webpacked into build per webpack.server.config.js */
//**(11) frontend will have access to build/public because of this route provided for /dist */
//**(12) build/public contains the javascript for the frontend components/store/routes 
//* also contains the css 
//* also contains the images files*/
//**(13) Hence, line 28 route and line 38 route provide all files necessary to the browser */
//**(3) build folder files are generated by webpack */
app.use("/dist", express.static(path.resolve(PWD,'build','public')))

//**(1) following method used traditionally without express.static */
// app.use('/dist/:file', (req,res)=>{
//     res.sendFile(req.params.file, {root: path.resolve(PWD,'build','public')})
// })

//**(5) This will provide index.html to all the routes.Hence navigating any links will not afraid don't have index.html which is not the case for chap14 when you click backwards will show no page contents */
//**(6) We are using backend server service to effectively make available index.html to the various routes */
//**(7) Same applies to the static files in build/public. The webpacked compiled css and js files need to make available to index.html  */
app.use('*', (req,res) => {
    res.sendFile('index.html', {root: PWD})
})

//**(8) the express routes will connect to PORT */

app.listen(PORT , ()=> console.log(`Running Server on port ${PORT}`))